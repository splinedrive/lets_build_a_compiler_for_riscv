!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Abort	cradle.c	/^void Abort(char *s) {$/;"	f
Add	main.c	/^void Add() {$/;"	f
AddEndtry	cradle.c	/^void AddEndtry(Symbol N, char T) {$/;"	f
Alloc	main.c	/^void Alloc() {$/;"	f
Allocate	main.c	/^void Allocate(char *Name, char *Val) {$/;"	f
Assignment	main.c	/^void Assignment() {$/;"	f
Block	main.c	/^void Block(char *L) {$/;"	f
BoolExpression	main.c	/^void BoolExpression() {$/;"	f
BoolOr	main.c	/^void BoolOr() {$/;"	f
BoolTerm	main.c	/^void BoolTerm() {$/;"	f
BoolXor	main.c	/^void BoolXor() {$/;"	f
Branch	main.c	/^void Branch(char *L) {$/;"	f
BranchFalse	main.c	/^void BranchFalse(char *L) {$/;"	f
CC	riscv_sim/Makefile	/^CC = $(RV_PREFIX)gcc #Our compiler$/;"	m
CCFLAGS	riscv_sim/Makefile	/^CCFLAGS = -nostdlib -mcmodel=medany -Tlink.ld #Flags telling GCC to compile without libraries (e.g. baremetal), to use a differen memory model so that we can put our code at 0x80000000 and to use the specified linker script.$/;"	m
COMMENT_SEMANTIC	main.c	10;"	d	file:
CheckDup	cradle.c	/^void CheckDup(Symbol N) {$/;"	f
CheckIdent	cradle.c	/^void CheckIdent() {$/;"	f
CheckTable	cradle.c	/^void CheckTable(Symbol N) {$/;"	f
Clear	main.c	/^void Clear() { EmitLn("li t0,0"); }$/;"	f
CompareExpression	main.c	/^void CompareExpression() {$/;"	f
DEBUG	cradle.h	3;"	d
Divide	main.c	/^void Divide() {$/;"	f
DoBreak	main.c	/^void DoBreak(char *L) {$/;"	f
DoIf	main.c	/^void DoIf(char *L) {$/;"	f
DoRead	main.c	/^void DoRead() {$/;"	f
DoWhile	main.c	/^void DoWhile() {$/;"	f
DoWrite	main.c	/^void DoWrite() {$/;"	f
Duplicate	cradle.c	/^void Duplicate(char *s) {$/;"	f
Emit	cradle.c	/^void Emit(char *s) { printf("\\t%s", s); }$/;"	f
EmitLn	cradle.c	/^void EmitLn(char *s) {$/;"	f
Epilog	main.c	/^void Epilog() { EmitLn("ret"); \/*EmitLn(".section .data");*\/ }$/;"	f
Equals	main.c	/^void Equals() {$/;"	f
Error	cradle.c	/^void Error(char *s) { printf("\\nError: %s.", s); }$/;"	f
Expected	cradle.c	/^void Expected(char *s) {$/;"	f
Expression	main.c	/^void Expression() {$/;"	f
FLAGS	Makefile	/^FLAGS=-g -Wall -Werror$/;"	m
Factor	main.c	/^void Factor() {$/;"	f
GetChar	cradle.c	/^void GetChar() { Look = getchar(); }$/;"	f
GetName	cradle.c	/^void GetName() {$/;"	f
GetNum	cradle.c	/^void GetNum() {$/;"	f
GetOp	cradle.c	/^void GetOp() {$/;"	f
Greater	main.c	/^void Greater() {$/;"	f
Halt	cradle.c	/^void Halt() {$/;"	f
Header	main.c	/^void Header() {$/;"	f
I	a.s	/^	I:	 .word 33$/;"	l
I	riscv_sim/a.s	/^	I:	 .word 33$/;"	l
I	test.S	/^I:	 .word 0$/;"	l
IN	Makefile	/^IN=main.c cradle.c$/;"	m
InTable	cradle.c	/^int InTable(Symbol n) { return Lookup(ST, n, MaxEntry) >= 0; }$/;"	f
Init	cradle.c	/^void Init() {$/;"	f
IsAddop	cradle.c	/^int IsAddop(char c) { return (c == '+' || c == '-'); }$/;"	f
IsAlNum	cradle.c	/^int IsAlNum(char c) { return IsDigit(c) || IsAlpha(c); }$/;"	f
IsAlpha	cradle.c	/^int IsAlpha(char c) {$/;"	f
IsDigit	cradle.c	/^int IsDigit(char c) { return (c >= '0' && c <= '9'); }$/;"	f
IsMulop	cradle.c	/^int IsMulop(char c) { return (c == '*' || c == '\/'); }$/;"	f
IsOrop	cradle.c	/^int IsOrop(char c) { return strchr("|~", c) != 0; }$/;"	f
IsRelop	cradle.c	/^int IsRelop(char c) { return strchr("=#<>", c) != 0; }$/;"	f
IsWhite	cradle.c	/^int IsWhite(char c) { return strchr(" \\t\\r\\n", c) != 0; }$/;"	f
J	test.S	/^J:	 .word 0$/;"	l
KWCode	cradle.c	/^const char KWCode[] = "xilewebRWve";$/;"	v
KWList	cradle.c	/^Symbol KWList[] = {{"IF"},    {"ELSE"}, {"ENDIF"}, {"WHILE"}, {"ENDWHILE"},$/;"	v
L00	a.s	/^L00:$/;"	l
L00	riscv_sim/a.s	/^L00:$/;"	l
L00	test.S	/^L00:$/;"	l
L01	a.s	/^L01:$/;"	l
L01	riscv_sim/a.s	/^L01:$/;"	l
L01	test.S	/^L01:$/;"	l
L02	a.s	/^L02:$/;"	l
L02	riscv_sim/a.s	/^L02:$/;"	l
L02	test.S	/^L02:$/;"	l
L03	a.s	/^L03:$/;"	l
L03	riscv_sim/a.s	/^L03:$/;"	l
LCount	cradle.c	/^static int LCount = 0;$/;"	v	file:
Less	main.c	/^void Less() {$/;"	f
LessOrEqual	main.c	/^void LessOrEqual() {$/;"	f
LoadConst	main.c	/^void LoadConst(char *n) {$/;"	f
LoadVar	main.c	/^void LoadVar(char *Name) {$/;"	f
Locate	cradle.c	/^int Locate(Symbol N) { return (Lookup(ST, N, MaxEntry)); }$/;"	f
Look	cradle.c	/^char Look;$/;"	v
Lookup	cradle.c	/^int Lookup(TabPtr T, char *s, int n) {$/;"	f
MAX_LABEL_LEN	cradle.h	7;"	d
MAX_MSG_LEN	cradle.h	5;"	d
MAX_SPRINTF_LEN	cradle.h	6;"	d
MAX_TOKEN_LEN	cradle.h	4;"	d
Match	cradle.c	/^void Match(char x) {$/;"	f
MatchString	cradle.c	/^void MatchString(char *x) {$/;"	f
MaxEntry	cradle.h	8;"	d
Multiply	main.c	/^void Multiply() {$/;"	f
NEntry	cradle.c	/^static int NEntry = 0;$/;"	v	file:
NKW	cradle.c	/^const int NKW = sizeof(KWList) \/ sizeof(Symbol);$/;"	v
NKW1	cradle.c	/^const int NKW1 = sizeof(KWCode) \/ sizeof(char);$/;"	v
NewLabel	cradle.c	/^char *NewLabel() {$/;"	f
NewLine	cradle.c	/^void NewLine() {$/;"	f
Next	cradle.c	/^void Next() {$/;"	f
NextExpression	main.c	/^void NextExpression() {$/;"	f
NotEqual	main.c	/^void NotEqual() {$/;"	f
NotFactor	main.c	/^void NotFactor() {$/;"	f
NotIt	main.c	/^void NotIt() {$/;"	f
OUT	Makefile	/^OUT=main$/;"	m
OUT_FILE	riscv_sim/Makefile	/^OUT_FILE = a.out$/;"	m
PopAdd	main.c	/^void PopAdd() {$/;"	f
PopAnd	main.c	/^void PopAnd() {$/;"	f
PopCompare	main.c	/^void PopCompare() {$/;"	f
PopDiv	main.c	/^void PopDiv() {$/;"	f
PopMul	main.c	/^void PopMul() {$/;"	f
PopOr	main.c	/^void PopOr() {$/;"	f
PopSub	main.c	/^void PopSub() {$/;"	f
PopXor	main.c	/^void PopXor() {$/;"	f
PostLabel	cradle.c	/^void PostLabel(char *L) { printf("%s:\\n", L); }$/;"	f
Prolog	main.c	/^void Prolog() {$/;"	f
Push	main.c	/^void Push() {$/;"	f
RV_PREFIX	riscv_sim/Makefile	/^RV_PREFIX = riscv32-unknown-elf-#Prefix for our RISC-V tools (e.g. gcc and objdump)$/;"	m
ReadIt	main.c	/^void ReadIt(char *Name) {$/;"	f
ReadVar	main.c	/^void ReadVar() {$/;"	f
Relation	main.c	/^void Relation() {$/;"	f
ST	cradle.c	/^Symbol ST[MaxEntry];$/;"	v
SType	cradle.c	/^char SType[MaxEntry];$/;"	v
SUM	test.S	/^SUM:	 .word 0$/;"	l
SYMBOL_LEN	cradle.h	14;"	d
Scan	cradle.c	/^void Scan() {$/;"	f
Semi	cradle.c	/^void Semi() {$/;"	f
SetEqual	main.c	/^void SetEqual() {$/;"	f
SetGreater	main.c	/^void SetGreater() {$/;"	f
SetGreaterOrEqual	main.c	/^void SetGreaterOrEqual() {$/;"	f
SetLess	main.c	/^void SetLess() {$/;"	f
SetLessOrEqual	main.c	/^void SetLessOrEqual() {$/;"	f
SetNEqual	main.c	/^void SetNEqual() {$/;"	f
SkipWhite	cradle.c	/^void SkipWhite() {$/;"	f
Store	main.c	/^void Store(char *Name) {$/;"	f
Subtract	main.c	/^void Subtract() {$/;"	f
SymTab	cradle.h	/^typedef Symbol SymTab[1000];$/;"	t
Symbol	cradle.h	/^typedef char Symbol[SYMBOL_LEN];$/;"	t
TabPtr	cradle.h	/^typedef SymTab TabPtr;$/;"	t
Term	main.c	/^void Term() {$/;"	f
Token	cradle.c	/^char Token;$/;"	v
TopDecls	main.c	/^void TopDecls() {$/;"	f
UART_READ	cradle.h	11;"	d
UART_WRITE	cradle.h	10;"	d
Undefined	cradle.c	/^void Undefined(char *s) {$/;"	f
UpCase	cradle.h	13;"	d
Value	cradle.c	/^char Value[MAX_TOKEN_LEN];$/;"	v
WriteIt	main.c	/^void WriteIt() {$/;"	f
_CRADLE_H	cradle.h	2;"	d
_start	a.s	/^_start:$/;"	l
_start	riscv_sim/a.s	/^_start:$/;"	l
_start	test.S	/^_start:$/;"	l
bindata	riscv_sim/makehex.py	/^    bindata = f.read()$/;"	v
binfile	riscv_sim/makehex.py	/^binfile = argv[1]$/;"	v
entry	riscv_sim/init.s	/^entry:$/;"	l
labelName	cradle.c	/^static char labelName[MAX_LABEL_LEN];$/;"	v	file:
main	main.c	/^int main() {$/;"	f
nwords	riscv_sim/makehex.py	/^nwords = int(argv[2])$/;"	v
tmp	cradle.h	/^char tmp[MAX_SPRINTF_LEN];$/;"	v
token_buf	cradle.c	/^char *token_buf;$/;"	v
w	riscv_sim/makehex.py	/^        w = bindata[4*i : 4*i+4]$/;"	v
