!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Abort	cradle.c	/^void Abort(char *s) {$/;"	f
AddEndtry	cradle.c	/^void AddEndtry(char Name, char T) {$/;"	f
AddParam	cradle.c	/^void AddParam(char Name) {$/;"	f
Alloc	main.c	/^void Alloc(char N) {$/;"	f
Allocate	main.c	/^void Allocate(char *Name, char *Val) {$/;"	f
Assignment	main.c	/^void Assignment(char Name) {$/;"	f
AssignmentOrProc	main.c	/^void AssignmentOrProc() {$/;"	f
Base	main.c	/^int Base;$/;"	v
BeginBlock	main.c	/^void BeginBlock() {$/;"	f
Branch	main.c	/^void Branch(char *L) {$/;"	f
BranchFalse	main.c	/^void BranchFalse(char *L) {$/;"	f
CC	riscv_sim/Makefile	/^CC = $(RV_PREFIX)gcc #Our compiler$/;"	m
CCFLAGS	riscv_sim/Makefile	/^CCFLAGS = -nostdlib -mcmodel=medany -Tlink.ld #Flags telling GCC to compile without libraries (e.g. baremetal), to use a differen memory model so that we can put our code at 0x80000000 and to use the specified linker script.$/;"	m
COMMENT_SEMANTIC	main.c	17;"	d	file:
Call	main.c	/^void Call(char N) {$/;"	f
CallProc	main.c	/^void CallProc(char N) {$/;"	f
CheckVar	cradle.c	/^void CheckVar(char Name) {$/;"	f
Clear	main.c	/^void Clear() { EmitLn("li t0,0"); }$/;"	f
ClearParams	cradle.c	/^void ClearParams() {$/;"	f
DEBUG	cradle.h	3;"	d
Decl	main.c	/^void Decl() {$/;"	f
DoBlock	main.c	/^void DoBlock() {$/;"	f
DoMain	main.c	/^void DoMain() {$/;"	f
DoProc	main.c	/^void DoProc() {$/;"	f
Duplicate	cradle.c	/^void Duplicate(char *s) {$/;"	f
Emit	cradle.c	/^void Emit(char *s) { printf("\\t%s", s); }$/;"	f
EmitLn	cradle.c	/^void EmitLn(char *s) {$/;"	f
Epilog	main.c	/^void Epilog() { EmitLn("ret"); \/*EmitLn(".section .data");*\/ }$/;"	f
Error	cradle.c	/^void Error(char *s) { printf("\\nError: %s.", s); }$/;"	f
Expected	cradle.c	/^void Expected(char *s) {$/;"	f
Expression	main.c	/^void Expression() {$/;"	f
FLAGS	Makefile	/^FLAGS=-g -Wall -Werror$/;"	m
Fin	cradle.c	/^void Fin() {$/;"	f
FormalList	main.c	/^void FormalList() {$/;"	f
FormalParam	main.c	/^void FormalParam() {$/;"	f
GetChar	cradle.c	/^void GetChar() { Look = getchar(); }$/;"	f
GetName	cradle.c	/^char GetName() {$/;"	f
GetNum	cradle.c	/^char GetNum() {$/;"	f
Halt	cradle.c	/^void Halt() {$/;"	f
Header	main.c	/^void Header() {$/;"	f
I	a.s	/^	I:	 .word 33$/;"	l
I	riscv_sim/a.s	/^	I:	 .word 33$/;"	l
I	test.S	/^I:	 .word 0$/;"	l
IN	Makefile	/^IN=main.c cradle.c$/;"	m
InTable	cradle.c	/^int InTable(char n) { return ST[n - 'A'] != ' '; }$/;"	f
Init	cradle.c	/^void Init() {$/;"	f
IsAddop	cradle.c	/^int IsAddop(char c) { return (c == '+' || c == '-'); }$/;"	f
IsAlNum	cradle.c	/^int IsAlNum(char c) { return IsDigit(c) || IsAlpha(c); }$/;"	f
IsAlpha	cradle.c	/^int IsAlpha(char c) {$/;"	f
IsDigit	cradle.c	/^int IsDigit(char c) { return (c >= '0' && c <= '9'); }$/;"	f
IsMulop	cradle.c	/^int IsMulop(char c) { return (c == '*' || c == '\/'); }$/;"	f
IsOrop	cradle.c	/^int IsOrop(char c) { return strchr("|~", c) != 0; }$/;"	f
IsParam	cradle.c	/^int IsParam(char N) { return ParamNumber(N) != 0; }$/;"	f
IsRelop	cradle.c	/^int IsRelop(char c) { return strchr("=#<>", c) != 0; }$/;"	f
IsWhite	cradle.c	/^int IsWhite(char c) { return strchr(" \\t\\r\\n{", c) != 0; }$/;"	f
J	test.S	/^J:	 .word 0$/;"	l
L00	a.s	/^L00:$/;"	l
L00	riscv_sim/a.s	/^L00:$/;"	l
L00	test.S	/^L00:$/;"	l
L01	a.s	/^L01:$/;"	l
L01	riscv_sim/a.s	/^L01:$/;"	l
L01	test.S	/^L01:$/;"	l
L02	a.s	/^L02:$/;"	l
L02	riscv_sim/a.s	/^L02:$/;"	l
L02	test.S	/^L02:$/;"	l
L03	a.s	/^L03:$/;"	l
L03	riscv_sim/a.s	/^L03:$/;"	l
LCount	cradle.c	/^static int LCount = 0;$/;"	v	file:
LoadConst	main.c	/^void LoadConst(char *n) {$/;"	f
LoadParam	main.c	/^void LoadParam(int N) {$/;"	f
LoadVar	main.c	/^void LoadVar(char Name) {$/;"	f
LocDecl	main.c	/^void LocDecl() {$/;"	f
LocDecls	main.c	/^int LocDecls() {$/;"	f
Look	cradle.c	/^char Look;$/;"	v
MAX_LABEL_LEN	cradle.h	7;"	d
MAX_MSG_LEN	cradle.h	5;"	d
MAX_SPRINTF_LEN	cradle.h	6;"	d
MAX_TOKEN_LEN	cradle.h	4;"	d
Match	cradle.c	/^void Match(char x) {$/;"	f
MaxEntry	cradle.h	8;"	d
NewLabel	cradle.c	/^char *NewLabel() {$/;"	f
NewLine	cradle.c	/^void NewLine() {$/;"	f
NotIt	main.c	/^void NotIt() {$/;"	f
NumParams	cradle.c	/^int NumParams;$/;"	v
OUT	Makefile	/^OUT=main$/;"	m
OUT_FILE	riscv_sim/Makefile	/^OUT_FILE = a.out$/;"	m
Param	main.c	/^void Param() {$/;"	f
ParamList	main.c	/^void ParamList() {$/;"	f
ParamNumber	cradle.c	/^int ParamNumber(char N) { return Params[N - 'A']; }$/;"	f
Params	cradle.c	/^int Params['Z' - 'A'];$/;"	v
PopAdd	main.c	/^void PopAdd() {$/;"	f
PopAnd	main.c	/^void PopAnd() {$/;"	f
PopDiv	main.c	/^void PopDiv() {$/;"	f
PopMul	main.c	/^void PopMul() {$/;"	f
PopOr	main.c	/^void PopOr() {$/;"	f
PopSub	main.c	/^void PopSub() {$/;"	f
PopXor	main.c	/^void PopXor() {$/;"	f
PostLabel	cradle.c	/^void PostLabel(char *L) { printf("%s:\\n", L); }$/;"	f
ProcEpilog	main.c	/^void ProcEpilog(char N, int k) {$/;"	f
ProcProlog	main.c	/^void ProcProlog(char N, int k) {$/;"	f
Prolog	main.c	/^void Prolog() {$/;"	f
Push	main.c	/^void Push() {$/;"	f
RV_PREFIX	riscv_sim/Makefile	/^RV_PREFIX = riscv32-unknown-elf-#Prefix for our RISC-V tools (e.g. gcc and objdump)$/;"	m
Return	main.c	/^void Return() {$/;"	f
ST	cradle.c	/^char ST['Z' - 'A'];$/;"	v
ST	cradle.h	/^char ST['Z' - 'A'];$/;"	v
SUM	test.S	/^SUM:	 .word 0$/;"	l
SYMBOL_LEN	cradle.h	14;"	d
SkipComment	cradle.c	/^void SkipComment() {$/;"	f
SkipWhite	cradle.c	/^void SkipWhite() {$/;"	f
StoreParam	main.c	/^void StoreParam(int N) {$/;"	f
StoreVar	main.c	/^void StoreVar(char Name) {$/;"	f
TopDecls	main.c	/^void TopDecls() {$/;"	f
TypeOf	cradle.c	/^char TypeOf(char n) {$/;"	f
UART_READ	cradle.h	11;"	d
UART_WRITE	cradle.h	10;"	d
Undefined	cradle.c	/^void Undefined(char *s) {$/;"	f
UpCase	cradle.h	13;"	d
Value	cradle.c	/^char Value[MAX_TOKEN_LEN];$/;"	v
_CRADLE_H	cradle.h	2;"	d
_start	a.s	/^_start:$/;"	l
_start	riscv_sim/a.s	/^_start:$/;"	l
_start	test.S	/^_start:$/;"	l
bindata	riscv_sim/makehex.py	/^    bindata = f.read()$/;"	v
binfile	riscv_sim/makehex.py	/^binfile = argv[1]$/;"	v
entry	riscv_sim/init.s	/^entry:$/;"	l
labelName	cradle.c	/^static char labelName[MAX_LABEL_LEN];$/;"	v	file:
main	main.c	/^int main() {$/;"	f
nwords	riscv_sim/makehex.py	/^nwords = int(argv[2])$/;"	v
tmp	cradle.h	/^char tmp[MAX_SPRINTF_LEN];$/;"	v
w	riscv_sim/makehex.py	/^        w = bindata[4*i : 4*i+4]$/;"	v
